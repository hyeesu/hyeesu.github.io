---
title: architecture란?
categories: [IT]
comments: true
---

<br>
프로젝트 회의를 하다보면 아키텍처에 대한 얘기가 계속 나오는데..<br>
그럴 때마다 이해 못하는 내 자신이 너무 화가 나서 적어본다...ㅎㅎ<br>
<br>

<h2><strong>architecture란?</strong></h2>
<br>
1. 시스템 구성 및 동작 원리를 나타낸다.
<br>
2. 시스템 구성 요소(부품)에 대해 설계 및 구현을 지원하는 수준으로 자세히 기술된다.
<br>
3. 구성 요소 간의 관계 및 시스템 외부 환경과의 관계가 묘사된다.
<br>
4. 요구 사양 및 시스템의 전체 수명주기를 고려한다.
<br>
5. 시스템 전체(하드웨어, 소프트웨어 포괄)에 대한 논리적인 기능 체계와 그것을 실현하기 위한 구성 방식
<br>

즉, 아키텍처는 시스템(서비스)의 동작 원리이다.

<br>

<h2><strong>architecture 목표</strong></h2>
<br>
1. 시스템의 전체적인 최적화

<br>

<h2><strong>architecture 설계 과정</strong></h2>
<br>
1. 설계 목표 설정
<br>
1-1. 시스템 개발 방향을 명확히 하기 위해 설계에 영향을 주는 비즈니스 목표와 우선순위 등 요구사항을 분석하여 전체 시스템 설계 목표 설정
<br>
2. 시스템 타입 설정
<br>
 2-1. 시스템과 서브시스템의 타입을 결정하고, 설계 목표와 함께 고려하여 아키텍처 패턴 선택
<br>
    <table class="table table-striped table-bordered">
        <thead>
            <tr>
                <th colspan="2">시스템 타입</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th rowspan="4">대화형 시스템<br>(interactive)</th>
                <th>사용자의 요청이 발생하면 시스템이 요구사항을 처리하고 반응</th>
            </tr>
            <tr>
                <th>시스템은 한 명의 사용자하고만 대화함</th>
            </tr>
            <tr>
                <th>대화가 사용자에 의해 시작되고 종료됨</th>
            </tr>
            <tr>
                <th>ex) 로그인, 결제 서비스 등</th>
            </tr>                           
            <tr>  
                <th rowspan="7">이벤트 중심 시스템<br>(event-driven)</th>
                <th>외부의 상태에 따라 이벤트를 받고 제어하는 시스템</th>
            </tr> 
            <tr>
                <th>입력 순서가 정해져 있지 않고, 요구가 불규칙하게 시스템에 요청됨</th>
            </tr>
            <tr>
                <th>모든 입력 이벤트에 대해 반응할 필요 없음</th>
            </tr>                        
            <tr>
                <th>외부 엔티티는 주로 하드웨어 장치나 다른 소프트웨어 시스템</th>
            </tr>  
            <tr>
                <th>일반적으로 상태 다이어그램 모델링을 하게 됨</th>
            </tr>                                               
            <tr>
                <th>시스템에 시간 제약이나 순서 제약 필요성 있음</th>
            </tr>      
            <tr>
                <th>ex) 임베디드 시스템 (내장형 시스템, 내부에 탑재된 컴퓨터)</th>
            </tr>                                                       
            <tr>
                <th rowspan="4">변환형 시스템<br>(transformational)</th>
                <th>데이터가 입력되면 정해진 작업들을 수행하여 결과를 출력하는 시스템<br>(입력을 출력으로 변환)</th>
            </tr>  
            <tr>
                <th>상태가 존재하지 않음</th>
            </tr>                     
            <tr>
                <th>엔지니어링 분야와 데이터 마이닝과 같은 비즈니스 어플리케이션에서 많이 쓰임</th>
            </tr>   
            <tr>
                <th>ex) 컴파일러 (원시코드를 실행코드로 변환)</th>
            </tr>                                           
            <tr>
                <th rowspan="3">객체 영속형 시스템<br>(object-persistence)</th>
                <th>데이터 베이스를 사용하여 파일을 효과적으로 저장, 검색, 갱신할 수 있는 시스템<br>(데이터베이스 시스템)</th>
            </tr> 
            <tr>
                <th>데이터베이스를 숨기고 구현에 대한 변경을 시스템이 모르도록 보호함</th>
            </tr>          
            <tr>
                <th>대규모의 데이터를 효과적으로 저장, 검색, 갱신 가능해야함</th>
            </tr>                 
        </tbody>
    </table>
3. 아키텍처 패턴 적용
<br>
 3-1. 아키텍처 패턴을 참조하여 시스템 표준 아키텍처 설계
<br>
4. 서브시스템 구체화
<br>
 4-1. 서브시스템의 기능 및 서브시스템 간의 상호작용을 위한 동작과 인터페이스 정의
<br>
5. 검토
<br>
 5-1. 아키텍처가 설계 목표에 부합하는지, 요구사항이 반영 되었는지, 설계의 기본원리를 만족하는지 등 검토

<br>

<h2><strong>architecture 패턴?</strong></h2>
<br>
1. 다양한 상황에서 아키텍처 설계 시 공통적인 발생 문제들을 해결하기 위해 일반화된 솔루션 (해결책)
<br>
2. 디자인 패턴보다 더 큰 범주에 속하며 소프트웨어의 구조의 구성을 위한 윤곽
<br>
3. 아키텍처 패턴은 소프트웨어 설계의 기본이며 재사용 될 수 있는 모형들을 정립한 약속
<br>
4. 정립이 된 상태로 설계를 하기 때문에 개발자간 소스 파악이 쉽다.
<br>

<br>

<h2><strong>architecture 패턴의 장점?</strong></h2>
<br>
1. 시행 착오를 줄여 개발 시간 단축
<br>
2. 검증된 구조로 개발하여 안정적인 개발 가능
<br>
3. 공통된 아키텍처 공유로 인해 의사소통 원활
<br>
4. 시스템 구조 이해가 쉬워 유지보수에 용이함
<br>

<br>

<h2><strong>architecture 패턴의 종류?</strong></h2>
<br>
1. 레이어 패턴
<br>
• 서브 시스템들이 계층구조를 이룬다.
<br>
• 상위 계층은 하위 계층의 서비스 제공자가 됨
<br>
• 하위 계층은 상위 계층의 클라이언트가 됨
<br>
• ex) OSI 계층
<br>
2. 클라이언트-서버 패턴
<br>
• 하나의 서버와 다수의 클라이언트로 구성
<br>
• 서버 컴포넌트는 다수의 클라이언트 요청이 올 때마다 서비스 제공하기 때문에 서버는 계속 대기하고 있는 상태
<br>
• ex) 이메일, 문서 공유, 은행 등
<br>
3. 마스터-슬레이브 패턴
<br>
• 마스터 컴포넌트는 동등한 구조를 지닌 슬레이브 컴포넌트들로 작업 분산
<br>
• 슬레이브가 반환한 결과 값으로 최종 결과 값 계산
<br>
• ex) 버스와 연결된 주변장치, 병렬 컴퓨팅, 장애허용 시스템
<br>
4. 파이프-필터 패턴
<br>
• 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능
<br>
• 처리 과정은 필터 컴포넌트에서 이뤄지고, 처리되는 데이터는 파이프를 통해 흐름
<br>
• 버퍼링 또는 동기화 목적으로 사용될 수 있음
<br>
• ex) 컴파일러, unix shell
<br>
5. 브로커 패턴
<br>
• 분리된 컴포넌트들로 이루어진 분산환경 시스템에서 사용
<br>
• 원격 서비스 실행을 통해 서로 상호작용 가능
<br>
• 브로커 컴포넌트는 컴포넌트 간의 통신을 조정하는 역할
<br>
• ex) 분산환경 시스템
<br>
6. 피어 투 피어 패턴
<br>
• 각 컴포넌트들을 '피어'라고 부름
<br>
• 피어는 클라이언트와 서버 모두 될 수 있음
<br>
• ex) 파일 공유 네트워크, 멀티미디어 프로토콜
<br>
7. 이벤트-버스 패턴
<br>
• 주로 이벤트를 처리하고 이벤트 소스, 리스너, 채널, 버스라는 주요 컴포넌트를 가짐
<br>
• 소스는 이벤트 버스를 통해 특정 채널로 메세지를 발행 (publish)
<br>
• 리스너는 특정 채널에서 메세지를 구독 (subscribe)
<br>
• 리스너는 이전에 구독한 채널에 발행된 메세지에 대한 알림을 받음
<br>
• ex) 안드로이드 개발, 알림 서비스
<br>
8. MVC패턴
<br>
• 사용자에게 제공되거나 받는 방식에서 내부적인 표현을 분리하기 위함
<br>
• 컴포넌트를 분리하며 코드의 효율적인 재사용을 가능하게 함
<br>
• ex) 웹 어플리케이션 설계 아키텍처, 웹 프레임워크
    <table class="table table-striped table-bordered">
        <thead>
            <tr>
                <th colspan="2">대화형 애플리케이션 파트</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>model</th>
                <th>핵심 기능과 데이터 포함</th>
            </tr>
            <tr>
                <th>view</th>
                <th>사용자에게 정보 표시</th>
            </tr>                       
            <tr>
                <th>controller</th>
                <th>사용자로 발생한 입력 처리</th>
            </tr>                
        </tbody>
    </table>
9. 블랙보드 패턴
<br>
• 해결책이 명확하지 않을 때 유용
<br>
• 모든 컴포넌트는 블랙보드에 접근하여 추가되는 새로운 데이터 객체를 생성할 수 있음
<br>
• 컴포넌트는 블랙보드에서 특정 종류의 데이터를 찾음
<br>
• 기존 지식 소스와의 '패턴매칭'으로 데이터를 찾음
<br>
• ex) 음성인식, 차량 식별 및 추적, 신호해석
    <table class="table table-striped table-bordered">
        <thead>
            <tr>
                <th colspan="2">주요 컴포넌트</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th>블랙보드</th>
                <th>솔루션의 객체를 포함하는 구조화된 전역 메모리</th>
            </tr>
            <tr>
                <th>지식소스</th>
                <th>자체 표현을 가진 특수 모듈</th>
            </tr>                       
            <tr>
                <th>제어 컴포넌트</th>
                <th>모듈 선택, 설정 및 실행 담당</th>
            </tr>                
        </tbody>
    </table>
10. 인터프리터 패턴
<br>
• 특정 언어로 작성된 프로그램을 해석하는 컴포넌트를 설계할 때 주로 사용
<br>
• 기본 아이디어는 언어의 각 기호에 대해 클래스 생성
<br>
• ex) SQL, 통신프로토콜 정의어
<br>